// Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package merkle

import (
	"math"

	"github.com/PaddlePaddle/PaddleDTX/crypto/core/hash"
)

// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,
// stores it using a linear array, and returns a slice of the backing array.  A
// linear array was chosen as opposed to an actual tree structure since it uses
// about half as much memory.  The following describes a merkle tree and how it
// is stored in a linear array.
//从交易片段创建默克尔树，
//使用线性数组存储它，并返回后备数组的一部分。 一个
//选择线性阵列而不是实际的树结构，因为它使用
//大约一半的内存。 下面描述了一个默克尔树及其方式
//存储在线性数组中。
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.  A diagram depicting how this works for bitcoin transactions
// where h(x) is a double sha256 follows:
//Merkle 树是一棵树，其中每个非叶节点都是其哈希
//子节点。 描述比特币交易如何工作的图表
//其中 h（x） 是双 SHA256 如下：

//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows: 上面存储为线性数组如下：
//
// 	[h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array. 如上所示，默克尔根始终是数组中的最后一个元素。
//
// The number of inputs is not always a power of two which results in a
// balanced tree structure as above.  In that case, parent nodes with no
// children are also zero and parent nodes with only a single left node
// are calculated by concatenating the left node with itself before hashing.
// Since this function uses nodes that are pointers to the hashes, empty nodes
// will be nil.
//输入的数量并不总是 2 的幂，这导致
//平衡的树结构如上。 在这种情况下，没有父节点
//子节点也为零，父节点只有一个左节点
//通过在哈希之前将左节点与自身连接起来来计算。
//由于此函数使用指向哈希的节点，因此空节点
//将为零。
//
// The additional bool parameter indicates if we are generating the merkle tree
// using witness transaction id's rather than regular transaction id's. This
// also presents an additional case wherein the wtxid of the coinbase transaction
// is the zeroHash.
//附加的 bool 参数指示我们是否正在生成默克尔树
//使用见证事务 ID 而不是常规事务 ID。这
//还提出了一个额外的案例，其中Coinbase交易的WTXID是
//是零哈希。
func BuildMerkleTreeStore(objects [][]byte) [][]byte {
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	//计算持有二进制默克尔需要多少个条目
	//	树作为线性数组，并创建该大小的数组。
	nextPoT := nextPowerOfTwo(len(objects))
	arraySize := nextPoT*2 - 1
	merkles := make([][]byte, arraySize)

	copy(merkles, objects)

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	//在最后一个事务之后开始数组偏移量，并调整为
	//	二的次方。
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.当没有左子节点时，父节点也为零。
		case merkles[i] == nil:
			merkles[offset] = nil

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		//当没有合适的子代时，父级由
		//		散列左子项与自身的串联。
		case merkles[i+1] == nil:
			newHash := HashMerkleBranches(merkles[i], merkles[i])
			merkles[offset] = newHash

		// The normal case sets the parent node to the double sha256
		// of the concatentation of the left and right children.
		//正常情况下将父节点设置为双 sha256
		//		左右孩子的融合。
		default:
			newHash := HashMerkleBranches(merkles[i], merkles[i+1])
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
//返回给定数字中的下一个最高幂 2，如果
//它已经不是二的幂。 这是在
//默克尔树的计算。
func nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2. 如果数字已经是 2 的幂，则返回该数字。
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two. 计算并返回 2 的下一个幂。
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

// HashMerkleBranches takes two hashes, treated as the left and right tree
// nodes, and returns the hash of their concatenation.  This is a helper
// function used to aid in the generation of a merkle tree.
//取两个哈希值，视为左右树
//节点，并返回其串联的哈希值。 这是一个帮手
//用于帮助生成默克尔树的函数。
func HashMerkleBranches(left []byte, right []byte) []byte {
	// Concatenate the left and right nodes. 连接左右节点。
	h := append(append([]byte{}, left...), right...)

	newHash := DoubleHashH(h)
	return newHash
}

// DoubleHashH calculates hash(hash(b)) and returns the resulting bytes as a Hash 计算哈希（哈希（b））并将结果字节作为哈希返回
func DoubleHashH(b []byte) []byte {
	first := hash.HashUsingSha256(b)
	return hash.HashUsingSha256(first[:])
}

// GetMerkleRoot calculate merkle root of several objects 计算多个对象的默克尔根
func GetMerkleRoot(objects [][]byte) []byte {
	tree := BuildMerkleTreeStore(objects)
	return tree[len(tree)-1]
}
